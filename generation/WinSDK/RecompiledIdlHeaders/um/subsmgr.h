/*** Autogenerated by WIDL 5.0 from ./subsmgr.idl - Do not edit ***/

#ifdef _WIN32
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif
#include <rpc.h>
#include <rpcndr.h>
#endif

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __subsmgr_h__
#define __subsmgr_h__

/* Forward declarations */

#ifndef __IEnumItemProperties_FWD_DEFINED__
#define __IEnumItemProperties_FWD_DEFINED__
typedef interface IEnumItemProperties IEnumItemProperties;
#ifdef __cplusplus
interface IEnumItemProperties;
#endif /* __cplusplus */
#endif

#ifndef __ISubscriptionItem_FWD_DEFINED__
#define __ISubscriptionItem_FWD_DEFINED__
typedef interface ISubscriptionItem ISubscriptionItem;
#ifdef __cplusplus
interface ISubscriptionItem;
#endif /* __cplusplus */
#endif

#ifndef __IEnumSubscription_FWD_DEFINED__
#define __IEnumSubscription_FWD_DEFINED__
typedef interface IEnumSubscription IEnumSubscription;
#ifdef __cplusplus
interface IEnumSubscription;
#endif /* __cplusplus */
#endif

#ifndef __ISubscriptionMgr_FWD_DEFINED__
#define __ISubscriptionMgr_FWD_DEFINED__
typedef interface ISubscriptionMgr ISubscriptionMgr;
#ifdef __cplusplus
interface ISubscriptionMgr;
#endif /* __cplusplus */
#endif

#ifndef __ISubscriptionMgr2_FWD_DEFINED__
#define __ISubscriptionMgr2_FWD_DEFINED__
typedef interface ISubscriptionMgr2 ISubscriptionMgr2;
#ifdef __cplusplus
interface ISubscriptionMgr2;
#endif /* __cplusplus */
#endif

#ifndef __SubscriptionMgr_FWD_DEFINED__
#define __SubscriptionMgr_FWD_DEFINED__
#ifdef __cplusplus
typedef class SubscriptionMgr SubscriptionMgr;
#else
typedef struct SubscriptionMgr SubscriptionMgr;
#endif /* defined __cplusplus */
#endif /* defined __SubscriptionMgr_FWD_DEFINED__ */

/* Headers for imported files */

#include <unknwn.h>
#include <ocidl.h>
#include <oleidl.h>
#include <oaidl.h>

#ifdef __cplusplus
extern "C" {
#endif

//=--------------------------------------------------------------------------=
// subsmgr.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#include <winapifamily.h>

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Channel Manager Interfaces.

typedef GUID SUBSCRIPTIONCOOKIE;
/*****************************************************************************
 * IEnumItemProperties interface
 */
#ifndef __IEnumItemProperties_INTERFACE_DEFINED__
#define __IEnumItemProperties_INTERFACE_DEFINED__

typedef IEnumItemProperties *LPENUMITEMPROPERTIES;
typedef struct _tagITEMPROP {
    VARIANT variantValue;
    LPWSTR pwszName;
} ITEMPROP;
typedef struct _tagITEMPROP *LPITEMPROP;
DEFINE_GUID(IID_IEnumItemProperties, 0xf72c8d96, 0x6dbd, 0x11d1, 0xa1,0xe8, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("f72c8d96-6dbd-11d1-a1e8-00c04fc2fbe1")
IEnumItemProperties : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Next(
        ULONG celt,
        ITEMPROP *rgelt,
        ULONG *pceltFetched) = 0;

    virtual HRESULT STDMETHODCALLTYPE Skip(
        ULONG celt) = 0;

    virtual HRESULT STDMETHODCALLTYPE Reset(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone(
        IEnumItemProperties **ppenum) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetCount(
        ULONG *pnCount) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IEnumItemProperties, 0xf72c8d96, 0x6dbd, 0x11d1, 0xa1,0xe8, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1)
#endif
#else
typedef struct IEnumItemPropertiesVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IEnumItemProperties *This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IEnumItemProperties *This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IEnumItemProperties *This);

    /*** IEnumItemProperties methods ***/
    HRESULT (STDMETHODCALLTYPE *Next)(
        IEnumItemProperties *This,
        ULONG celt,
        ITEMPROP *rgelt,
        ULONG *pceltFetched);

    HRESULT (STDMETHODCALLTYPE *Skip)(
        IEnumItemProperties *This,
        ULONG celt);

    HRESULT (STDMETHODCALLTYPE *Reset)(
        IEnumItemProperties *This);

    HRESULT (STDMETHODCALLTYPE *Clone)(
        IEnumItemProperties *This,
        IEnumItemProperties **ppenum);

    HRESULT (STDMETHODCALLTYPE *GetCount)(
        IEnumItemProperties *This,
        ULONG *pnCount);

    END_INTERFACE
} IEnumItemPropertiesVtbl;

interface IEnumItemProperties {
    CONST_VTBL IEnumItemPropertiesVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IEnumItemProperties_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEnumItemProperties_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEnumItemProperties_Release(This) (This)->lpVtbl->Release(This)
/*** IEnumItemProperties methods ***/
#define IEnumItemProperties_Next(This,celt,rgelt,pceltFetched) (This)->lpVtbl->Next(This,celt,rgelt,pceltFetched)
#define IEnumItemProperties_Skip(This,celt) (This)->lpVtbl->Skip(This,celt)
#define IEnumItemProperties_Reset(This) (This)->lpVtbl->Reset(This)
#define IEnumItemProperties_Clone(This,ppenum) (This)->lpVtbl->Clone(This,ppenum)
#define IEnumItemProperties_GetCount(This,pnCount) (This)->lpVtbl->GetCount(This,pnCount)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IEnumItemProperties_QueryInterface(IEnumItemProperties* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IEnumItemProperties_AddRef(IEnumItemProperties* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IEnumItemProperties_Release(IEnumItemProperties* This) {
    return This->lpVtbl->Release(This);
}
/*** IEnumItemProperties methods ***/
static FORCEINLINE HRESULT IEnumItemProperties_Next(IEnumItemProperties* This,ULONG celt,ITEMPROP *rgelt,ULONG *pceltFetched) {
    return This->lpVtbl->Next(This,celt,rgelt,pceltFetched);
}
static FORCEINLINE HRESULT IEnumItemProperties_Skip(IEnumItemProperties* This,ULONG celt) {
    return This->lpVtbl->Skip(This,celt);
}
static FORCEINLINE HRESULT IEnumItemProperties_Reset(IEnumItemProperties* This) {
    return This->lpVtbl->Reset(This);
}
static FORCEINLINE HRESULT IEnumItemProperties_Clone(IEnumItemProperties* This,IEnumItemProperties **ppenum) {
    return This->lpVtbl->Clone(This,ppenum);
}
static FORCEINLINE HRESULT IEnumItemProperties_GetCount(IEnumItemProperties* This,ULONG *pnCount) {
    return This->lpVtbl->GetCount(This,pnCount);
}
#endif
#endif

#endif


#endif  /* __IEnumItemProperties_INTERFACE_DEFINED__ */

//  Subscription item flag values
//  Temporary subscription item
#define SI_TEMPORARY         0x80000000
/*****************************************************************************
 * ISubscriptionItem interface
 */
#ifndef __ISubscriptionItem_INTERFACE_DEFINED__
#define __ISubscriptionItem_INTERFACE_DEFINED__

typedef ISubscriptionItem *LPSUBSCRIPTIONITEM;
//  SUBSCRIPTIONITEMINFO flags                               
//  To specify that an item should only run on user idle     
//  use TASK_FLAG_START_ONLY_IF_IDLE                         
typedef struct tagSUBSCRIPTIONITEMINFO {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwPriority;
    SUBSCRIPTIONCOOKIE ScheduleGroup;
    CLSID clsidAgent;
} SUBSCRIPTIONITEMINFO;
DEFINE_GUID(IID_ISubscriptionItem, 0xa97559f8, 0x6c4a, 0x11d1, 0xa1,0xe8, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("a97559f8-6c4a-11d1-a1e8-00c04fc2fbe1")
ISubscriptionItem : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetCookie(
        SUBSCRIPTIONCOOKIE *pCookie) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSubscriptionItemInfo(
        SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetSubscriptionItemInfo(
        const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo) = 0;

    virtual HRESULT STDMETHODCALLTYPE ReadProperties(
        ULONG nCount,
        const LPCWSTR rgwszName[],
        VARIANT rgValue[]) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteProperties(
        ULONG nCount,
        const LPCWSTR rgwszName[],
        const VARIANT rgValue[]) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumProperties(
        IEnumItemProperties **ppEnumItemProperties) = 0;

    virtual HRESULT STDMETHODCALLTYPE NotifyChanged(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(ISubscriptionItem, 0xa97559f8, 0x6c4a, 0x11d1, 0xa1,0xe8, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1)
#endif
#else
typedef struct ISubscriptionItemVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        ISubscriptionItem *This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        ISubscriptionItem *This);

    ULONG (STDMETHODCALLTYPE *Release)(
        ISubscriptionItem *This);

    /*** ISubscriptionItem methods ***/
    HRESULT (STDMETHODCALLTYPE *GetCookie)(
        ISubscriptionItem *This,
        SUBSCRIPTIONCOOKIE *pCookie);

    HRESULT (STDMETHODCALLTYPE *GetSubscriptionItemInfo)(
        ISubscriptionItem *This,
        SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);

    HRESULT (STDMETHODCALLTYPE *SetSubscriptionItemInfo)(
        ISubscriptionItem *This,
        const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);

    HRESULT (STDMETHODCALLTYPE *ReadProperties)(
        ISubscriptionItem *This,
        ULONG nCount,
        const LPCWSTR rgwszName[],
        VARIANT rgValue[]);

    HRESULT (STDMETHODCALLTYPE *WriteProperties)(
        ISubscriptionItem *This,
        ULONG nCount,
        const LPCWSTR rgwszName[],
        const VARIANT rgValue[]);

    HRESULT (STDMETHODCALLTYPE *EnumProperties)(
        ISubscriptionItem *This,
        IEnumItemProperties **ppEnumItemProperties);

    HRESULT (STDMETHODCALLTYPE *NotifyChanged)(
        ISubscriptionItem *This);

    END_INTERFACE
} ISubscriptionItemVtbl;

interface ISubscriptionItem {
    CONST_VTBL ISubscriptionItemVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define ISubscriptionItem_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ISubscriptionItem_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ISubscriptionItem_Release(This) (This)->lpVtbl->Release(This)
/*** ISubscriptionItem methods ***/
#define ISubscriptionItem_GetCookie(This,pCookie) (This)->lpVtbl->GetCookie(This,pCookie)
#define ISubscriptionItem_GetSubscriptionItemInfo(This,pSubscriptionItemInfo) (This)->lpVtbl->GetSubscriptionItemInfo(This,pSubscriptionItemInfo)
#define ISubscriptionItem_SetSubscriptionItemInfo(This,pSubscriptionItemInfo) (This)->lpVtbl->SetSubscriptionItemInfo(This,pSubscriptionItemInfo)
#define ISubscriptionItem_ReadProperties(This,nCount,rgwszName,rgValue) (This)->lpVtbl->ReadProperties(This,nCount,rgwszName,rgValue)
#define ISubscriptionItem_WriteProperties(This,nCount,rgwszName,rgValue) (This)->lpVtbl->WriteProperties(This,nCount,rgwszName,rgValue)
#define ISubscriptionItem_EnumProperties(This,ppEnumItemProperties) (This)->lpVtbl->EnumProperties(This,ppEnumItemProperties)
#define ISubscriptionItem_NotifyChanged(This) (This)->lpVtbl->NotifyChanged(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT ISubscriptionItem_QueryInterface(ISubscriptionItem* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG ISubscriptionItem_AddRef(ISubscriptionItem* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG ISubscriptionItem_Release(ISubscriptionItem* This) {
    return This->lpVtbl->Release(This);
}
/*** ISubscriptionItem methods ***/
static FORCEINLINE HRESULT ISubscriptionItem_GetCookie(ISubscriptionItem* This,SUBSCRIPTIONCOOKIE *pCookie) {
    return This->lpVtbl->GetCookie(This,pCookie);
}
static FORCEINLINE HRESULT ISubscriptionItem_GetSubscriptionItemInfo(ISubscriptionItem* This,SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo) {
    return This->lpVtbl->GetSubscriptionItemInfo(This,pSubscriptionItemInfo);
}
static FORCEINLINE HRESULT ISubscriptionItem_SetSubscriptionItemInfo(ISubscriptionItem* This,const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo) {
    return This->lpVtbl->SetSubscriptionItemInfo(This,pSubscriptionItemInfo);
}
static FORCEINLINE HRESULT ISubscriptionItem_ReadProperties(ISubscriptionItem* This,ULONG nCount,const LPCWSTR rgwszName[],VARIANT rgValue[]) {
    return This->lpVtbl->ReadProperties(This,nCount,rgwszName,rgValue);
}
static FORCEINLINE HRESULT ISubscriptionItem_WriteProperties(ISubscriptionItem* This,ULONG nCount,const LPCWSTR rgwszName[],const VARIANT rgValue[]) {
    return This->lpVtbl->WriteProperties(This,nCount,rgwszName,rgValue);
}
static FORCEINLINE HRESULT ISubscriptionItem_EnumProperties(ISubscriptionItem* This,IEnumItemProperties **ppEnumItemProperties) {
    return This->lpVtbl->EnumProperties(This,ppEnumItemProperties);
}
static FORCEINLINE HRESULT ISubscriptionItem_NotifyChanged(ISubscriptionItem* This) {
    return This->lpVtbl->NotifyChanged(This);
}
#endif
#endif

#endif


#endif  /* __ISubscriptionItem_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IEnumSubscription interface
 */
#ifndef __IEnumSubscription_INTERFACE_DEFINED__
#define __IEnumSubscription_INTERFACE_DEFINED__

typedef IEnumSubscription *LPENUMSUBSCRIPTION;
DEFINE_GUID(IID_IEnumSubscription, 0xf72c8d97, 0x6dbd, 0x11d1, 0xa1,0xe8, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("f72c8d97-6dbd-11d1-a1e8-00c04fc2fbe1")
IEnumSubscription : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Next(
        ULONG celt,
        SUBSCRIPTIONCOOKIE *rgelt,
        ULONG *pceltFetched) = 0;

    virtual HRESULT STDMETHODCALLTYPE Skip(
        ULONG celt) = 0;

    virtual HRESULT STDMETHODCALLTYPE Reset(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone(
        IEnumSubscription **ppenum) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetCount(
        ULONG *pnCount) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IEnumSubscription, 0xf72c8d97, 0x6dbd, 0x11d1, 0xa1,0xe8, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1)
#endif
#else
typedef struct IEnumSubscriptionVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IEnumSubscription *This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IEnumSubscription *This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IEnumSubscription *This);

    /*** IEnumSubscription methods ***/
    HRESULT (STDMETHODCALLTYPE *Next)(
        IEnumSubscription *This,
        ULONG celt,
        SUBSCRIPTIONCOOKIE *rgelt,
        ULONG *pceltFetched);

    HRESULT (STDMETHODCALLTYPE *Skip)(
        IEnumSubscription *This,
        ULONG celt);

    HRESULT (STDMETHODCALLTYPE *Reset)(
        IEnumSubscription *This);

    HRESULT (STDMETHODCALLTYPE *Clone)(
        IEnumSubscription *This,
        IEnumSubscription **ppenum);

    HRESULT (STDMETHODCALLTYPE *GetCount)(
        IEnumSubscription *This,
        ULONG *pnCount);

    END_INTERFACE
} IEnumSubscriptionVtbl;

interface IEnumSubscription {
    CONST_VTBL IEnumSubscriptionVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IEnumSubscription_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEnumSubscription_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEnumSubscription_Release(This) (This)->lpVtbl->Release(This)
/*** IEnumSubscription methods ***/
#define IEnumSubscription_Next(This,celt,rgelt,pceltFetched) (This)->lpVtbl->Next(This,celt,rgelt,pceltFetched)
#define IEnumSubscription_Skip(This,celt) (This)->lpVtbl->Skip(This,celt)
#define IEnumSubscription_Reset(This) (This)->lpVtbl->Reset(This)
#define IEnumSubscription_Clone(This,ppenum) (This)->lpVtbl->Clone(This,ppenum)
#define IEnumSubscription_GetCount(This,pnCount) (This)->lpVtbl->GetCount(This,pnCount)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IEnumSubscription_QueryInterface(IEnumSubscription* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IEnumSubscription_AddRef(IEnumSubscription* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IEnumSubscription_Release(IEnumSubscription* This) {
    return This->lpVtbl->Release(This);
}
/*** IEnumSubscription methods ***/
static FORCEINLINE HRESULT IEnumSubscription_Next(IEnumSubscription* This,ULONG celt,SUBSCRIPTIONCOOKIE *rgelt,ULONG *pceltFetched) {
    return This->lpVtbl->Next(This,celt,rgelt,pceltFetched);
}
static FORCEINLINE HRESULT IEnumSubscription_Skip(IEnumSubscription* This,ULONG celt) {
    return This->lpVtbl->Skip(This,celt);
}
static FORCEINLINE HRESULT IEnumSubscription_Reset(IEnumSubscription* This) {
    return This->lpVtbl->Reset(This);
}
static FORCEINLINE HRESULT IEnumSubscription_Clone(IEnumSubscription* This,IEnumSubscription **ppenum) {
    return This->lpVtbl->Clone(This,ppenum);
}
static FORCEINLINE HRESULT IEnumSubscription_GetCount(IEnumSubscription* This,ULONG *pnCount) {
    return This->lpVtbl->GetCount(This,pnCount);
}
#endif
#endif

#endif


#endif  /* __IEnumSubscription_INTERFACE_DEFINED__ */


DEFINE_GUID(LIBID_SubscriptionMgr, 0xc54fd88a, 0xffa1, 0x11d0, 0xbc,0x5e, 0x00,0xc0,0x4f,0xd9,0x29,0xdb);

/*****************************************************************************
 * ISubscriptionMgr interface
 */
#ifndef __ISubscriptionMgr_INTERFACE_DEFINED__
#define __ISubscriptionMgr_INTERFACE_DEFINED__

typedef enum SUBSCRIPTIONTYPE {
    SUBSTYPE_URL = 0,
    SUBSTYPE_CHANNEL = 1,
    SUBSTYPE_DESKTOPURL = 2,
    SUBSTYPE_EXTERNAL = 3,
    SUBSTYPE_DESKTOPCHANNEL = 4
} SUBSCRIPTIONTYPE;
typedef enum SUBSCRIPTIONINFOFLAGS {
    SUBSINFO_SCHEDULE = 0x1,
    SUBSINFO_RECURSE = 0x2,
    SUBSINFO_WEBCRAWL = 0x4,
    SUBSINFO_MAILNOT = 0x8,
    SUBSINFO_MAXSIZEKB = 0x10,
    SUBSINFO_USER = 0x20,
    SUBSINFO_PASSWORD = 0x40,
    SUBSINFO_TASKFLAGS = 0x100,
    SUBSINFO_GLEAM = 0x200,
    SUBSINFO_CHANGESONLY = 0x400,
    SUBSINFO_CHANNELFLAGS = 0x800,
    SUBSINFO_FRIENDLYNAME = 0x2000,
    SUBSINFO_NEEDPASSWORD = 0x4000,
    SUBSINFO_TYPE = 0x8000
} SUBSCRIPTIONINFOFLAGS;
#define SUBSINFO_ALLFLAGS      0x0000EF7F
typedef enum CREATESUBSCRIPTIONFLAGS {
    CREATESUBS_ADDTOFAVORITES = 0x1,
    CREATESUBS_FROMFAVORITES = 0x2,
    CREATESUBS_NOUI = 0x4,
    CREATESUBS_NOSAVE = 0x8,
    CREATESUBS_SOFTWAREUPDATE = 0x10
} CREATESUBSCRIPTIONFLAGS;
typedef enum SUBSCRIPTIONSCHEDULE {
    SUBSSCHED_AUTO = 0,
    SUBSSCHED_DAILY = 1,
    SUBSSCHED_WEEKLY = 2,
    SUBSSCHED_CUSTOM = 3,
    SUBSSCHED_MANUAL = 4
} SUBSCRIPTIONSCHEDULE;
typedef struct _tagSubscriptionInfo {
    DWORD cbSize;
    DWORD fUpdateFlags;
    SUBSCRIPTIONSCHEDULE schedule;
    CLSID customGroupCookie;
    LPVOID pTrigger;
    DWORD dwRecurseLevels;
    DWORD fWebcrawlerFlags;
    BOOL bMailNotification;
    BOOL bGleam;
    BOOL bChangesOnly;
    BOOL bNeedPassword;
    DWORD fChannelFlags;
    BSTR bstrUserName;
    BSTR bstrPassword;
    BSTR bstrFriendlyName;
    DWORD dwMaxSizeKB;
    SUBSCRIPTIONTYPE subType;
    DWORD fTaskFlags;
    DWORD dwReserved;
} SUBSCRIPTIONINFO;
typedef struct _tagSubscriptionInfo *LPSUBSCRIPTIONINFO;
typedef struct _tagSubscriptionInfo *PSUBSCRIPTIONINFO;
DEFINE_GUID(IID_ISubscriptionMgr, 0x085fb2c0, 0x0df8, 0x11d1, 0x8f,0x4b, 0x00,0xa0,0xc9,0x05,0x41,0x3f);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("085fb2c0-0df8-11d1-8f4b-00a0c905413f")
ISubscriptionMgr : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE DeleteSubscription(
        LPCWSTR pwszURL,
        HWND hwnd) = 0;

    virtual HRESULT STDMETHODCALLTYPE UpdateSubscription(
        LPCWSTR pwszURL) = 0;

    virtual HRESULT STDMETHODCALLTYPE UpdateAll(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE IsSubscribed(
        LPCWSTR pwszURL,
        BOOL *pfSubscribed) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSubscriptionInfo(
        LPCWSTR pwszURL,
        SUBSCRIPTIONINFO *pInfo) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDefaultInfo(
        SUBSCRIPTIONTYPE subType,
        SUBSCRIPTIONINFO *pInfo) = 0;

    virtual HRESULT STDMETHODCALLTYPE ShowSubscriptionProperties(
        LPCWSTR pwszURL,
        HWND hwnd) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateSubscription(
        HWND hwnd,
        LPCWSTR pwszURL,
        LPCWSTR pwszFriendlyName,
        DWORD dwFlags,
        SUBSCRIPTIONTYPE subsType,
        SUBSCRIPTIONINFO *pInfo) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(ISubscriptionMgr, 0x085fb2c0, 0x0df8, 0x11d1, 0x8f,0x4b, 0x00,0xa0,0xc9,0x05,0x41,0x3f)
#endif
#else
typedef struct ISubscriptionMgrVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        ISubscriptionMgr *This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        ISubscriptionMgr *This);

    ULONG (STDMETHODCALLTYPE *Release)(
        ISubscriptionMgr *This);

    /*** ISubscriptionMgr methods ***/
    HRESULT (STDMETHODCALLTYPE *DeleteSubscription)(
        ISubscriptionMgr *This,
        LPCWSTR pwszURL,
        HWND hwnd);

    HRESULT (STDMETHODCALLTYPE *UpdateSubscription)(
        ISubscriptionMgr *This,
        LPCWSTR pwszURL);

    HRESULT (STDMETHODCALLTYPE *UpdateAll)(
        ISubscriptionMgr *This);

    HRESULT (STDMETHODCALLTYPE *IsSubscribed)(
        ISubscriptionMgr *This,
        LPCWSTR pwszURL,
        BOOL *pfSubscribed);

    HRESULT (STDMETHODCALLTYPE *GetSubscriptionInfo)(
        ISubscriptionMgr *This,
        LPCWSTR pwszURL,
        SUBSCRIPTIONINFO *pInfo);

    HRESULT (STDMETHODCALLTYPE *GetDefaultInfo)(
        ISubscriptionMgr *This,
        SUBSCRIPTIONTYPE subType,
        SUBSCRIPTIONINFO *pInfo);

    HRESULT (STDMETHODCALLTYPE *ShowSubscriptionProperties)(
        ISubscriptionMgr *This,
        LPCWSTR pwszURL,
        HWND hwnd);

    HRESULT (STDMETHODCALLTYPE *CreateSubscription)(
        ISubscriptionMgr *This,
        HWND hwnd,
        LPCWSTR pwszURL,
        LPCWSTR pwszFriendlyName,
        DWORD dwFlags,
        SUBSCRIPTIONTYPE subsType,
        SUBSCRIPTIONINFO *pInfo);

    END_INTERFACE
} ISubscriptionMgrVtbl;

interface ISubscriptionMgr {
    CONST_VTBL ISubscriptionMgrVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define ISubscriptionMgr_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ISubscriptionMgr_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ISubscriptionMgr_Release(This) (This)->lpVtbl->Release(This)
/*** ISubscriptionMgr methods ***/
#define ISubscriptionMgr_DeleteSubscription(This,pwszURL,hwnd) (This)->lpVtbl->DeleteSubscription(This,pwszURL,hwnd)
#define ISubscriptionMgr_UpdateSubscription(This,pwszURL) (This)->lpVtbl->UpdateSubscription(This,pwszURL)
#define ISubscriptionMgr_UpdateAll(This) (This)->lpVtbl->UpdateAll(This)
#define ISubscriptionMgr_IsSubscribed(This,pwszURL,pfSubscribed) (This)->lpVtbl->IsSubscribed(This,pwszURL,pfSubscribed)
#define ISubscriptionMgr_GetSubscriptionInfo(This,pwszURL,pInfo) (This)->lpVtbl->GetSubscriptionInfo(This,pwszURL,pInfo)
#define ISubscriptionMgr_GetDefaultInfo(This,subType,pInfo) (This)->lpVtbl->GetDefaultInfo(This,subType,pInfo)
#define ISubscriptionMgr_ShowSubscriptionProperties(This,pwszURL,hwnd) (This)->lpVtbl->ShowSubscriptionProperties(This,pwszURL,hwnd)
#define ISubscriptionMgr_CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo) (This)->lpVtbl->CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT ISubscriptionMgr_QueryInterface(ISubscriptionMgr* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG ISubscriptionMgr_AddRef(ISubscriptionMgr* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG ISubscriptionMgr_Release(ISubscriptionMgr* This) {
    return This->lpVtbl->Release(This);
}
/*** ISubscriptionMgr methods ***/
static FORCEINLINE HRESULT ISubscriptionMgr_DeleteSubscription(ISubscriptionMgr* This,LPCWSTR pwszURL,HWND hwnd) {
    return This->lpVtbl->DeleteSubscription(This,pwszURL,hwnd);
}
static FORCEINLINE HRESULT ISubscriptionMgr_UpdateSubscription(ISubscriptionMgr* This,LPCWSTR pwszURL) {
    return This->lpVtbl->UpdateSubscription(This,pwszURL);
}
static FORCEINLINE HRESULT ISubscriptionMgr_UpdateAll(ISubscriptionMgr* This) {
    return This->lpVtbl->UpdateAll(This);
}
static FORCEINLINE HRESULT ISubscriptionMgr_IsSubscribed(ISubscriptionMgr* This,LPCWSTR pwszURL,BOOL *pfSubscribed) {
    return This->lpVtbl->IsSubscribed(This,pwszURL,pfSubscribed);
}
static FORCEINLINE HRESULT ISubscriptionMgr_GetSubscriptionInfo(ISubscriptionMgr* This,LPCWSTR pwszURL,SUBSCRIPTIONINFO *pInfo) {
    return This->lpVtbl->GetSubscriptionInfo(This,pwszURL,pInfo);
}
static FORCEINLINE HRESULT ISubscriptionMgr_GetDefaultInfo(ISubscriptionMgr* This,SUBSCRIPTIONTYPE subType,SUBSCRIPTIONINFO *pInfo) {
    return This->lpVtbl->GetDefaultInfo(This,subType,pInfo);
}
static FORCEINLINE HRESULT ISubscriptionMgr_ShowSubscriptionProperties(ISubscriptionMgr* This,LPCWSTR pwszURL,HWND hwnd) {
    return This->lpVtbl->ShowSubscriptionProperties(This,pwszURL,hwnd);
}
static FORCEINLINE HRESULT ISubscriptionMgr_CreateSubscription(ISubscriptionMgr* This,HWND hwnd,LPCWSTR pwszURL,LPCWSTR pwszFriendlyName,DWORD dwFlags,SUBSCRIPTIONTYPE subsType,SUBSCRIPTIONINFO *pInfo) {
    return This->lpVtbl->CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo);
}
#endif
#endif

#endif


#endif  /* __ISubscriptionMgr_INTERFACE_DEFINED__ */

/*****************************************************************************
 * ISubscriptionMgr2 interface
 */
#ifndef __ISubscriptionMgr2_INTERFACE_DEFINED__
#define __ISubscriptionMgr2_INTERFACE_DEFINED__

//  Run State flags                                          
//  Item is ready and queued to run                          
#define RS_READY            0x00000001                       
//  Running item is paused                                   
#define RS_SUSPENDED        0x00000002                       
//  Item is updating                                         
#define RS_UPDATING         0x00000004                       
//  This item will be suspended while the user is not idle   
#define RS_SUSPENDONIDLE    0x00010000                       
//  This item is allowed to cause user interaction           
#define RS_MAYBOTHERUSER    0x00020000                       
//  Update is done                                           
#define RS_COMPLETED        0x80000000                       
//  Update flags                                             
//  Update window should start minimized                     
#define SUBSMGRUPDATE_MINIMIZE   0x00000001                  

#define SUBSMGRUPDATE_MASK       0x00000001                  
//  Enumeration flags                                        
//  Include temporary items                                  
#define SUBSMGRENUM_TEMP         0x00000001                  

#define SUBSMGRENUM_MASK         0x00000001                  
DEFINE_GUID(IID_ISubscriptionMgr2, 0x614bc270, 0xaedf, 0x11d1, 0xa1,0xf9, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("614bc270-aedf-11d1-a1f9-00c04fc2fbe1")
ISubscriptionMgr2 : public ISubscriptionMgr
{
    virtual HRESULT STDMETHODCALLTYPE GetItemFromURL(
        LPCWSTR pwszURL,
        ISubscriptionItem **ppSubscriptionItem) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetItemFromCookie(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        ISubscriptionItem **ppSubscriptionItem) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSubscriptionRunState(
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pCookies,
        DWORD *pdwRunState) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumSubscriptions(
        DWORD dwFlags,
        IEnumSubscription **ppEnumSubscriptions) = 0;

    virtual HRESULT STDMETHODCALLTYPE UpdateItems(
        DWORD dwFlags,
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pCookies) = 0;

    virtual HRESULT STDMETHODCALLTYPE AbortItems(
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pCookies) = 0;

    virtual HRESULT STDMETHODCALLTYPE AbortAll(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(ISubscriptionMgr2, 0x614bc270, 0xaedf, 0x11d1, 0xa1,0xf9, 0x00,0xc0,0x4f,0xc2,0xfb,0xe1)
#endif
#else
typedef struct ISubscriptionMgr2Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        ISubscriptionMgr2 *This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        ISubscriptionMgr2 *This);

    ULONG (STDMETHODCALLTYPE *Release)(
        ISubscriptionMgr2 *This);

    /*** ISubscriptionMgr methods ***/
    HRESULT (STDMETHODCALLTYPE *DeleteSubscription)(
        ISubscriptionMgr2 *This,
        LPCWSTR pwszURL,
        HWND hwnd);

    HRESULT (STDMETHODCALLTYPE *UpdateSubscription)(
        ISubscriptionMgr2 *This,
        LPCWSTR pwszURL);

    HRESULT (STDMETHODCALLTYPE *UpdateAll)(
        ISubscriptionMgr2 *This);

    HRESULT (STDMETHODCALLTYPE *IsSubscribed)(
        ISubscriptionMgr2 *This,
        LPCWSTR pwszURL,
        BOOL *pfSubscribed);

    HRESULT (STDMETHODCALLTYPE *GetSubscriptionInfo)(
        ISubscriptionMgr2 *This,
        LPCWSTR pwszURL,
        SUBSCRIPTIONINFO *pInfo);

    HRESULT (STDMETHODCALLTYPE *GetDefaultInfo)(
        ISubscriptionMgr2 *This,
        SUBSCRIPTIONTYPE subType,
        SUBSCRIPTIONINFO *pInfo);

    HRESULT (STDMETHODCALLTYPE *ShowSubscriptionProperties)(
        ISubscriptionMgr2 *This,
        LPCWSTR pwszURL,
        HWND hwnd);

    HRESULT (STDMETHODCALLTYPE *CreateSubscription)(
        ISubscriptionMgr2 *This,
        HWND hwnd,
        LPCWSTR pwszURL,
        LPCWSTR pwszFriendlyName,
        DWORD dwFlags,
        SUBSCRIPTIONTYPE subsType,
        SUBSCRIPTIONINFO *pInfo);

    /*** ISubscriptionMgr2 methods ***/
    HRESULT (STDMETHODCALLTYPE *GetItemFromURL)(
        ISubscriptionMgr2 *This,
        LPCWSTR pwszURL,
        ISubscriptionItem **ppSubscriptionItem);

    HRESULT (STDMETHODCALLTYPE *GetItemFromCookie)(
        ISubscriptionMgr2 *This,
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        ISubscriptionItem **ppSubscriptionItem);

    HRESULT (STDMETHODCALLTYPE *GetSubscriptionRunState)(
        ISubscriptionMgr2 *This,
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pCookies,
        DWORD *pdwRunState);

    HRESULT (STDMETHODCALLTYPE *EnumSubscriptions)(
        ISubscriptionMgr2 *This,
        DWORD dwFlags,
        IEnumSubscription **ppEnumSubscriptions);

    HRESULT (STDMETHODCALLTYPE *UpdateItems)(
        ISubscriptionMgr2 *This,
        DWORD dwFlags,
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pCookies);

    HRESULT (STDMETHODCALLTYPE *AbortItems)(
        ISubscriptionMgr2 *This,
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pCookies);

    HRESULT (STDMETHODCALLTYPE *AbortAll)(
        ISubscriptionMgr2 *This);

    END_INTERFACE
} ISubscriptionMgr2Vtbl;

interface ISubscriptionMgr2 {
    CONST_VTBL ISubscriptionMgr2Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define ISubscriptionMgr2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ISubscriptionMgr2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ISubscriptionMgr2_Release(This) (This)->lpVtbl->Release(This)
/*** ISubscriptionMgr methods ***/
#define ISubscriptionMgr2_DeleteSubscription(This,pwszURL,hwnd) (This)->lpVtbl->DeleteSubscription(This,pwszURL,hwnd)
#define ISubscriptionMgr2_UpdateSubscription(This,pwszURL) (This)->lpVtbl->UpdateSubscription(This,pwszURL)
#define ISubscriptionMgr2_UpdateAll(This) (This)->lpVtbl->UpdateAll(This)
#define ISubscriptionMgr2_IsSubscribed(This,pwszURL,pfSubscribed) (This)->lpVtbl->IsSubscribed(This,pwszURL,pfSubscribed)
#define ISubscriptionMgr2_GetSubscriptionInfo(This,pwszURL,pInfo) (This)->lpVtbl->GetSubscriptionInfo(This,pwszURL,pInfo)
#define ISubscriptionMgr2_GetDefaultInfo(This,subType,pInfo) (This)->lpVtbl->GetDefaultInfo(This,subType,pInfo)
#define ISubscriptionMgr2_ShowSubscriptionProperties(This,pwszURL,hwnd) (This)->lpVtbl->ShowSubscriptionProperties(This,pwszURL,hwnd)
#define ISubscriptionMgr2_CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo) (This)->lpVtbl->CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo)
/*** ISubscriptionMgr2 methods ***/
#define ISubscriptionMgr2_GetItemFromURL(This,pwszURL,ppSubscriptionItem) (This)->lpVtbl->GetItemFromURL(This,pwszURL,ppSubscriptionItem)
#define ISubscriptionMgr2_GetItemFromCookie(This,pSubscriptionCookie,ppSubscriptionItem) (This)->lpVtbl->GetItemFromCookie(This,pSubscriptionCookie,ppSubscriptionItem)
#define ISubscriptionMgr2_GetSubscriptionRunState(This,dwNumCookies,pCookies,pdwRunState) (This)->lpVtbl->GetSubscriptionRunState(This,dwNumCookies,pCookies,pdwRunState)
#define ISubscriptionMgr2_EnumSubscriptions(This,dwFlags,ppEnumSubscriptions) (This)->lpVtbl->EnumSubscriptions(This,dwFlags,ppEnumSubscriptions)
#define ISubscriptionMgr2_UpdateItems(This,dwFlags,dwNumCookies,pCookies) (This)->lpVtbl->UpdateItems(This,dwFlags,dwNumCookies,pCookies)
#define ISubscriptionMgr2_AbortItems(This,dwNumCookies,pCookies) (This)->lpVtbl->AbortItems(This,dwNumCookies,pCookies)
#define ISubscriptionMgr2_AbortAll(This) (This)->lpVtbl->AbortAll(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT ISubscriptionMgr2_QueryInterface(ISubscriptionMgr2* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG ISubscriptionMgr2_AddRef(ISubscriptionMgr2* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG ISubscriptionMgr2_Release(ISubscriptionMgr2* This) {
    return This->lpVtbl->Release(This);
}
/*** ISubscriptionMgr methods ***/
static FORCEINLINE HRESULT ISubscriptionMgr2_DeleteSubscription(ISubscriptionMgr2* This,LPCWSTR pwszURL,HWND hwnd) {
    return This->lpVtbl->DeleteSubscription(This,pwszURL,hwnd);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_UpdateSubscription(ISubscriptionMgr2* This,LPCWSTR pwszURL) {
    return This->lpVtbl->UpdateSubscription(This,pwszURL);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_UpdateAll(ISubscriptionMgr2* This) {
    return This->lpVtbl->UpdateAll(This);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_IsSubscribed(ISubscriptionMgr2* This,LPCWSTR pwszURL,BOOL *pfSubscribed) {
    return This->lpVtbl->IsSubscribed(This,pwszURL,pfSubscribed);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_GetSubscriptionInfo(ISubscriptionMgr2* This,LPCWSTR pwszURL,SUBSCRIPTIONINFO *pInfo) {
    return This->lpVtbl->GetSubscriptionInfo(This,pwszURL,pInfo);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_GetDefaultInfo(ISubscriptionMgr2* This,SUBSCRIPTIONTYPE subType,SUBSCRIPTIONINFO *pInfo) {
    return This->lpVtbl->GetDefaultInfo(This,subType,pInfo);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_ShowSubscriptionProperties(ISubscriptionMgr2* This,LPCWSTR pwszURL,HWND hwnd) {
    return This->lpVtbl->ShowSubscriptionProperties(This,pwszURL,hwnd);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_CreateSubscription(ISubscriptionMgr2* This,HWND hwnd,LPCWSTR pwszURL,LPCWSTR pwszFriendlyName,DWORD dwFlags,SUBSCRIPTIONTYPE subsType,SUBSCRIPTIONINFO *pInfo) {
    return This->lpVtbl->CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo);
}
/*** ISubscriptionMgr2 methods ***/
static FORCEINLINE HRESULT ISubscriptionMgr2_GetItemFromURL(ISubscriptionMgr2* This,LPCWSTR pwszURL,ISubscriptionItem **ppSubscriptionItem) {
    return This->lpVtbl->GetItemFromURL(This,pwszURL,ppSubscriptionItem);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_GetItemFromCookie(ISubscriptionMgr2* This,const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,ISubscriptionItem **ppSubscriptionItem) {
    return This->lpVtbl->GetItemFromCookie(This,pSubscriptionCookie,ppSubscriptionItem);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_GetSubscriptionRunState(ISubscriptionMgr2* This,DWORD dwNumCookies,const SUBSCRIPTIONCOOKIE *pCookies,DWORD *pdwRunState) {
    return This->lpVtbl->GetSubscriptionRunState(This,dwNumCookies,pCookies,pdwRunState);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_EnumSubscriptions(ISubscriptionMgr2* This,DWORD dwFlags,IEnumSubscription **ppEnumSubscriptions) {
    return This->lpVtbl->EnumSubscriptions(This,dwFlags,ppEnumSubscriptions);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_UpdateItems(ISubscriptionMgr2* This,DWORD dwFlags,DWORD dwNumCookies,const SUBSCRIPTIONCOOKIE *pCookies) {
    return This->lpVtbl->UpdateItems(This,dwFlags,dwNumCookies,pCookies);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_AbortItems(ISubscriptionMgr2* This,DWORD dwNumCookies,const SUBSCRIPTIONCOOKIE *pCookies) {
    return This->lpVtbl->AbortItems(This,dwNumCookies,pCookies);
}
static FORCEINLINE HRESULT ISubscriptionMgr2_AbortAll(ISubscriptionMgr2* This) {
    return This->lpVtbl->AbortAll(This);
}
#endif
#endif

#endif


#endif  /* __ISubscriptionMgr2_INTERFACE_DEFINED__ */

/*****************************************************************************
 * SubscriptionMgr coclass
 */

DEFINE_GUID(CLSID_SubscriptionMgr, 0xabbe31d0, 0x6dae, 0x11d0, 0xbe,0xca, 0x00,0xc0,0x4f,0xd9,0x40,0xbe);

#ifdef __cplusplus
class DECLSPEC_UUID("abbe31d0-6dae-11d0-beca-00c04fd940be") SubscriptionMgr;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(SubscriptionMgr, 0xabbe31d0, 0x6dae, 0x11d0, 0xbe,0xca, 0x00,0xc0,0x4f,0xd9,0x40,0xbe)
#endif
#endif



////////////////////////////////////////////////////////////////////////////
// Information Delivery Agent definitions
EXTERN_C const CLSID CLSID_WebCrawlerAgent;      
EXTERN_C const CLSID CLSID_DialAgent;            
EXTERN_C const CLSID CLSID_CDLAgent;             

// AgentFlags property for all delivery agents
typedef enum DELIVERY_AGENT_FLAGS {
    DELIVERY_AGENT_FLAG_NO_BROADCAST = 0x4,
    DELIVERY_AGENT_FLAG_NO_RESTRICTIONS = 0x8,
    DELIVERY_AGENT_FLAG_SILENT_DIAL = 0x10
} DELIVERY_AGENT_FLAGS;

// RecurseFlags property for web crawler
typedef enum WEBCRAWL_RECURSEFLAGS {
    WEBCRAWL_DONT_MAKE_STICKY = 0x1,
    WEBCRAWL_GET_IMAGES = 0x2,
    WEBCRAWL_GET_VIDEOS = 0x4,
    WEBCRAWL_GET_BGSOUNDS = 0x8,
    WEBCRAWL_GET_CONTROLS = 0x10,
    WEBCRAWL_LINKS_ELSEWHERE = 0x20,
    WEBCRAWL_IGNORE_ROBOTSTXT = 0x80,
    WEBCRAWL_ONLY_LINKS_TO_HTML = 0x100
} WEBCRAWL_RECURSEFLAGS;

// ChannelFlags property for channel agent
typedef enum CHANNEL_AGENT_FLAGS {
    CHANNEL_AGENT_DYNAMIC_SCHEDULE = 0x1,
    CHANNEL_AGENT_PRECACHE_SOME = 0x2,
    CHANNEL_AGENT_PRECACHE_ALL = 0x4,
    CHANNEL_AGENT_PRECACHE_SCRNSAVER = 0x8
} CHANNEL_AGENT_FLAGS;

// Status codes for completed delivery agents

// Maximum specified subscription size limit reached
#define INET_E_AGENT_MAX_SIZE_EXCEEDED       _HRESULT_TYPEDEF_(0x800C0F80L)      

// A few URLs failed but the base url and most sub-urls succeeded
#define INET_S_AGENT_PART_FAIL               _HRESULT_TYPEDEF_(0x000C0F81L)      

// Maximum cache limit reached
#define INET_E_AGENT_CACHE_SIZE_EXCEEDED     _HRESULT_TYPEDEF_(0x800C0F82L)      

// Connection to Internet failed
#define INET_E_AGENT_CONNECTION_FAILED       _HRESULT_TYPEDEF_(0x800C0F83L)      

// Scheduled updates are disabled
#define INET_E_SCHEDULED_UPDATES_DISABLED    _HRESULT_TYPEDEF_(0x800C0F84L)      

// Scheduled updates are restricted
#define INET_E_SCHEDULED_UPDATES_RESTRICTED  _HRESULT_TYPEDEF_(0x800C0F85L)      

// Scheduled update occurred before update interval elapse
#define INET_E_SCHEDULED_UPDATE_INTERVAL     _HRESULT_TYPEDEF_(0x800C0F86L)      

// Scheduled update occurred during a restricted time
#define INET_E_SCHEDULED_EXCLUDE_RANGE       _HRESULT_TYPEDEF_(0x800C0F87L)      

// Status codes used during updates

// We are about to exceed our size limit during operation
#define INET_E_AGENT_EXCEEDING_CACHE_SIZE    _HRESULT_TYPEDEF_(0x800C0F90L)      

// We extended the cache size
#define INET_S_AGENT_INCREASED_CACHE_SIZE    _HRESULT_TYPEDEF_(0x000C0F90L)      

// End Information Delivery Agent definitions
////////////////////////////////////////////////////////////////////////////


#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */

/* Begin additional prototypes for all interfaces */

ULONG           __RPC_USER VARIANT_UserSize     (ULONG *, ULONG, VARIANT *);
unsigned char * __RPC_USER VARIANT_UserMarshal  (ULONG *, unsigned char *, VARIANT *);
unsigned char * __RPC_USER VARIANT_UserUnmarshal(ULONG *, unsigned char *, VARIANT *);
void            __RPC_USER VARIANT_UserFree     (ULONG *, VARIANT *);
ULONG           __RPC_USER HWND_UserSize     (ULONG *, ULONG, HWND *);
unsigned char * __RPC_USER HWND_UserMarshal  (ULONG *, unsigned char *, HWND *);
unsigned char * __RPC_USER HWND_UserUnmarshal(ULONG *, unsigned char *, HWND *);
void            __RPC_USER HWND_UserFree     (ULONG *, HWND *);
ULONG           __RPC_USER BSTR_UserSize     (ULONG *, ULONG, BSTR *);
unsigned char * __RPC_USER BSTR_UserMarshal  (ULONG *, unsigned char *, BSTR *);
unsigned char * __RPC_USER BSTR_UserUnmarshal(ULONG *, unsigned char *, BSTR *);
void            __RPC_USER BSTR_UserFree     (ULONG *, BSTR *);

/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __subsmgr_h__ */
